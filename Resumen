Passport es un middleware de autenticación para node.js
Está diseñado para cumplir un único propósito: autenticar solicitudes. Passport encapsula perfectamente esta funcionalidad, a la vez que delega a la aplicación detalles no relacionados, como el acceso a los datos.
La autenticación puede ser realizda de diferentes maneras:
- Proveyendo un usuario y password
- Haciendo Single Sign-On (SSO) con las redes sociales
- Usando Web Authentication (WebAuthn) para permitir el uso de huellas dactilares o reconocimiento facial
Para soportar aplicaciones web y moviles, la autenticación se expone como una API.
El acceso a las APIS es protegido por credenciales basdaas en tokens usando OAuth

Passport proporciona un marco flexible que permite a una aplicación utilizar cualquiera de estos mecanismos de autenticación. Passport reduce la complejidad de la autenticación de una solicitud a una simple declaración:
app.post('/login/password', passport.authenticate('local'));

Hay tres conceptos que hay que tener en cuenta:
1. Middleware
2. Estrategias
3. Sesiones

1. Middleware
El siguiente código es un ejemplo de una ruta que autentica a un usuario con un nombre de usuario y una contraseña:
app.post('/login/password',
  passport.authenticate('local', { failureRedirect: '/login', failureMessage: true }),
  function(req, res) {
    res.redirect('/~' + req.user.username);
  });
En esta ruta, passport.authenticate() es el middleware que autenticará la solicitud. De forma predeterminada, cuando la autenticación es exitosa, la propiedad req.user se establece con el usuario autenticado, se establece una sesión y se llama a la siguiente función del stack. Esta siguiente función suele ser lógica específica de la aplicación que procesará la solicitud en nombre del usuario.
Si falla la autenticación, se enviará una respuesta HTTP 401 "No autorizado" y finalizará el ciclo de solicitud-respuesta. No se llamará a ninguna función adicional en la pila.
En las aplicaciones web tradicionales, que interactúan con el usuario mediante páginas HTML, formularios y redirecciones, se suele usar la opción "failureRedirect". En lugar de responder con un error "401 No autorizado", el navegador será redirigido a la ubicación indicada con un error "302 Encontrado". Esta ubicación suele ser la página de inicio de sesión, que permite al usuario intentar iniciar sesión de nuevo tras un error de autenticación. Esto suele combinarse con la opción "failureMessage", que añade un mensaje informativo a la sesión sobre el motivo del error de autenticación, que puede mostrarse al usuario.

2. Estrategias
Las estrategias se encargan de autenticar las solicitudes, lo cual se logra mediante la implementación de un mecanismo de autenticación. Los mecanismos de autenticación definen cómo codificar una credencial, como una contraseña o una aserción de un proveedor de identidad (IdP), en una solicitud. También especifican el procedimiento necesario para verificar dicha credencial. Si la credencial se verifica correctamente, la solicitud se autentica.
Existe una amplia variedad de mecanismos de autenticación y, por consiguiente, de estrategias. Las estrategias se distribuyen en paquetes separados que deben instalarse, configurarse y registrarse.
- Instalación
Por ejemplo, el siguiente comando instalará passport-local, un paquete que proporciona una estrategia para autenticarse con un nombre de usuario y una contraseña:
$ npm install passport-local
- Configuración
Una vez instalado el paquete, es necesario configurar la estrategia. La configuración varía según el mecanismo de autenticación, por lo que se recomienda consultar la documentación específica de cada estrategia. Dicho esto, existen patrones comunes que se encuentran en muchas estrategias.
El siguiente código es un ejemplo que configura LocalStrategy:
var LocalStrategy = require('passport-local');
var strategy = new LocalStrategy(function verify(username, password, cb) {
  db.get('SELECT * FROM users WHERE username = ?', [ username ], function(err, user) {
    if (err) { return cb(err); }
    if (!user) { return cb(null, false, { message: 'Incorrect username or password.' }); }
    
    crypto.pbkdf2(password, user.salt, 310000, 32, 'sha256', function(err, hashedPassword) {
      if (err) { return cb(err); }
      if (!crypto.timingSafeEqual(user.hashed_password, hashedPassword)) {
        return cb(null, false, { message: 'Incorrect username or password.' });
      }
      return cb(null, user);
    });
  });
});
Función Verify:
El constructor LocalStrategy toma una función como argumento. Esta función se conoce como función de verificación y es un patrón común en muchas estrategias. Al autenticar una solicitud, una estrategia analiza la credencial contenida en ella. A continuación, se llama a una función de verificación, que se encarga de determinar el usuario al que pertenece dicha credencial. Esto permite delegar el acceso a los datos a la aplicación.
En este ejemplo, la función de verificación ejecuta una consulta SQL para obtener un registro de usuario de la base de datos y, tras verificar la contraseña, devuelve el registro a la estrategia, autenticando así al usuario y estableciendo una sesión de inicio de sesión.
Dado que la propia aplicación proporciona la función de verificación, el acceso al almacenamiento persistente no está restringido. La aplicación puede usar cualquier sistema de almacenamiento de datos, incluyendo bases de datos relacionales, bases de datos gráficas o almacenes de documentos, y estructurar los datos dentro de esa base de datos según cualquier esquema.
Una función de verificación es específica de cada estrategia, y los argumentos exactos que recibe y los parámetros que proporciona dependerán del mecanismo de autenticación subyacente. Para los mecanismos de autenticación que implican secretos compartidos, como una contraseña, una función de verificación se encarga de verificar la credencial y asignar un usuario. Para los mecanismos que proporcionan autenticación criptográfica, una función de verificación suele asignar un usuario y una clave, la cual la estrategia utilizará para verificar criptográficamente la credencial.
Una función de verificación da como resultado una de tres condiciones: éxito, fracaso o error.
Si la función de verificación encuentra un usuario al que pertenece la credencial, y esa credencial es válida, llama a la devolución de llamada con el usuario que se autentica:
return cb(null, user);
Si la credencial no pertenece a un usuario conocido o no es válida, la función de verificación llama a la devolución de llamada con falso para indicar una falla de autenticación:
return cb(null, false);
Si ocurre un error, como que la base de datos no esté disponible, se llama a la devolución de llamada con un error, en el estilo idiomático de Node.js.
return cb(err);



